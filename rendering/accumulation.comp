#version 460 core
#extension GL_GOOGLE_include_directive : enable

#ifdef INTEL_PLATFORM
#undef Wave_Size
#define Wave_Size 16
#endif

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/random.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"

LOCAL_SIZE_LAYOUT;

void main() {
    //#define wsize RAY_BLOCK samplerUniform.blockBinCount
    int wsize = RAY_BLOCK samplerUniform.blockBinCount;
    int wcsize = int(gl_WorkGroupSize.x) / int(Wave_Size_RT);
    int wcount = min(tiled(wsize, wcsize), 10000000);
    ivec2 wh = ivec2(RAY_BLOCK samplerUniform.sceneRes.xy);

    // invoke available blocks
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = (w + int(gl_WorkGroupID.x)) * wcsize + int(Wave_Idx);

        // check if not reached blocks limit
        bool overflow = overflow || anyInvoc(overflow || anyInvoc(globalID >= wsize));
        IFALL(overflow) break;
        if (!overflow) {
            int cnt = readFLane(blockBins[globalID].fragCount );
            int idx = readFLane(blockBins[globalID].blockStart )-1;
            SB_BARRIER
            if (electedInvoc()) blockBins[globalID].fragCount   = 0;
            if (electedInvoc()) blockBins[globalID].blockStart  = 0;

            // texel prefix
            int texelHeader = readFLane(blockBinIndiceHeader(globalID)), texelFrom = (blockBins[globalID].texelFrom)-1;
            if (int(texelHeader) < 0 || int(texelFrom) < 0) continue;

            // scatter colors from block bins
            bool inv = overflow;
            int cnm = min(256, cnt);
            for (int m=0;m<cnm;m++) {
                SB_BARRIER
                bool inv = inv || (int(idx) < 0);
                IFALL(inv) break; // if overflow or bad texel
                IFANY(!inv) {
                    for (int tb = 0; tb < int(R_BLOCK_SIZE); tb += int(Wave_Size_RT)) {
                        SB_BARRIER
                        int nid = tb + int(Lane_Idx);
                        int ltex = m16i(texelHeader, nid);
                        int texel = texelFrom + ltex;

                        IFALL(nid >= R_BLOCK_SIZE) break;
                        if (nid < R_BLOCK_SIZE && ltex >= 0 && texelFrom >= 0) {
                            vec4 color = f16_f32(rayBlockNodes[idx][nid].data.dcolor);
                            if (int(texel) >= 0 && !SSC(RayActived(rayBlockNodes[idx][nid].data)) && max3_vec(color.xyz) >= 0.00001f) {
                                texelBuf.nodes[texel].color.xyz += max(color.xyz, 0.f.xxx);
                            }

                            // deactivate ray
                            WriteColor(rayBlockNodes[idx][nid].data.dcolor, 0.f.xxxx);
                            RayActived(rayBlockNodes[idx][nid].data, false_);
                        }
                    }
                    int preidx = readFLane(int(idx) >= 0 ? rayBlocks[idx].next : 0);
                    SB_BARRIER
                    if (electedInvoc() && int(idx) >= 0) {
                        rayBlocks[idx].next = 0;
                        rayBlocks[idx].indiceCount = 0;
                        rayBlocks[idx].blockBinId = 0;
                    }
                    idx = preidx-1;
                }
            }
            if (electedInvoc() && int(idx) >= 0) rayBlocks[idx].next = 0;
        }
    }
}
