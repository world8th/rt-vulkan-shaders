#version 460 core
#extension GL_GOOGLE_include_directive : enable

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"

layout ( binding = 0, set = 1, rgba32f ) uniform image2D presampled;
layout ( binding = 1, set = 1, rgba32f ) uniform image2D prefiltered;
layout ( binding = 2, set = 1, r32i ) uniform iimage2D sampleflags;

// additional buffers
#ifdef ENABLE_ADDITIONAL_BUFFERS
layout ( binding = 3, set = 1, rgba32f ) uniform image2D currdepth;
layout ( binding = 4, set = 1, rgba32f ) uniform image2D normalbuf;
layout ( binding = 5, set = 1, rgba32f ) uniform image2D albedobuf;
#endif

LOCAL_SIZE_LAYOUT;


void main() {
    ivec2 wh = ivec2(RAY_BLOCK samplerUniform.sceneRes.xy);
    ivec2 whs = imageSize(presampled).xy; whs.y /= 2;

    // conversion aspect ratio
    vec2 aspect = vec2(wh)/vec2(whs);
    ivec2 aspectSized = max(ivec2(ceil(aspect.x), ceil(aspect.y)), ivec2(1,1));
    
    int wsize = whs.x*whs.y;
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 10000000);
    for (int w=0;w<wcount;w+=int(gl_NumWorkGroups.x)) {
        int it = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        ivec2 xy = ivec2(it%whs.x,it/whs.x);

        // offset for gathering
        ivec2 scene_xy_offset = ivec2(round(xy * aspect));

        // initial samples
        float samplecount = 0.f; vec4 color = 0.f.xxxx;

        // gathering 
        for (int x=-aspectSized.x-1;x<aspectSized.x+1;x++) {
            for (int y=-aspectSized.y-1;y<aspectSized.y+1;y++) {
                ivec2 scene_xy = scene_xy_offset + ivec2(x, y);
                int ts = scene_xy.x + wh.x * scene_xy.y;

                // accumulate samples
                ivec2 texel_xy = ivec2(floor(texelBuf.nodes[ts].coord.xy * vec2(whs))) - xy.xy;
                if (texel_xy.x == 0 && texel_xy.y == 0) {
                    color += texelBuf.nodes[ts].color; samplecount += 1.f;
                    //texelBuf.nodes[ts].color = vec4(0.f.xxxx); 
                }
            }
        }

        if (samplecount > 0.f) {
            if (imageLoad(sampleflags, xy).x > 0) {
                ISTORE(sampleflags, xy, ivec4(0));
                ISTORE(presampled, xy, vec4(0.f));
            }

            vec4 currentState = imageLoad(presampled, xy);
            currentState.xyz = mix(color.xyz/samplecount, currentState.xyz, clamp(precIssue(currentState.w)/precIssue(currentState.w+samplecount), 0.f, 1.f));
            currentState.w += samplecount;
            ISTORE(presampled, xy, vec4(currentState));
        }
    }
}
