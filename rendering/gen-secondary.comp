#version 460 core
#extension GL_GOOGLE_include_directive : enable

#ifdef INTEL_PLATFORM
#undef Wave_Size
#define Wave_Size 8
#endif

#ifndef MAX_DEPTH
#define MAX_DEPTH 16
#endif

#define USE_EXTENDED_RAYLIB
#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define ROLE_ABILATION

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/mathlib.glsl"
#include "../include/random.glsl"
#include "../include/shadinglib.glsl"
#include "./submodules/environment.glsl"

struct SurfaceUnpacked {
     vec4 uvt; // UV, distance, triangle
     vec4 normalHeight; // normal with height mapping, will already interpolated with geometry
     vec4 specularGlossiness;
     vec4 tangent;
     vec4 bitangent;

    // color parameters
     vec4 emission;
     vec4 albedo;
} compositedHit;

int wasHit = -1;
#define hasProcedural (proceduralID != -1)

//#define hit firstHit

// ray hit states 
// 0 - invalid hit
// 1 - shadow, have no hit in traversing (enviroment only)
// 5 - shadow, may overlap with geometry
// 3 - regular, have no intersection (environment)
// 7 - regular, have intersection

// bitfield of state
// 0 - activity of incoming ray
// 1 - shadow ray type 
// 2 - have intersection status or not

int invokeSurface(inout bool overflow) {
    HitData hit; hit.payloadID = 0; wasHit = -1; // initial hit

    // initial composition
    compositedHit.uvt = vec4(vec2(0.f), INFINITY, intBitsToFloat(-1));
    compositedHit.emission = vec4(0.f);
    compositedHit.albedo = vec4(0.f,0.f,0.f,0.f);
    compositedHit.normalHeight = vec4(0.f);
    compositedHit.specularGlossiness = vec4(0.f);
    compositedHit.tangent = vec4(0.f);

    // if hit was had
    wasHit = overflow ? -1 : floatBitsToInt(currentRay.origin.w)-1;
    if (wasHit >= 0) hit = hits[wasHit]; else wasHit = -1;

    // load from payload if has
    IF (hit.payloadID > 0 && wasHit >= 0) { // if none, make as transparent
        HitPayload hitp = hitPayload[hit.payloadID-1];
        compositedHit.uvt = hit.uvt;
        compositedHit.albedo = hitp.albedo;
        compositedHit.emission = hitp.emission;
        compositedHit.specularGlossiness = hitp.specularGlossiness;
        compositedHit.normalHeight = hitp.normalHeight;
        compositedHit.tangent = hit.tangent;
        compositedHit.bitangent = hit.bitangent;
    } else {
        wasHit = -1;
    }

    IF (greaterEqualF(compositedHit.uvt.z, INFINITY-0.0001f)) wasHit = -1;
    WriteColor(currentRay.dcolor, vec4(max(0.0f.xxxx, f16_f32(currentRay.dcolor)).xyz, 1.f));
    currentRay.origin.xyz = fma(dcts(currentRay.cdirect.xy), compositedHit.uvt.zzz, currentRay.origin.xyz); // current set origin by distance
    currentRay.origin.w = FINT_ZERO; // reset chains
    if (overflow) RayActived(currentRay, false_); // if had overflow, invalidate ray

    // getting ray state
    int rayState = 0; // invalid ray 
    if (SSC(RayActived(currentRay)) && max3_vec(f16_f32(currentRay.dcolor.xy).xyz) >= 0.00001f) {
        if (RayType(currentRay) == 2) {
            rayState = wasHit >= 0 ? 5 : 1;
        } else {
            rayState = wasHit >= 0 ? 7 : 3;
        }
    }
    return rayState;
}

RayRework envShading(in RayRework rayTemplate, inout bool skipping) {

    // bad ray
    if (skipping) {
        RayActived(rayTemplate, false_);
        WriteColor(rayTemplate.dcolor, 0.f.xxxx);
    }

    // apply physical lights
    int lc = -1;
    IF (RayDL(rayTemplate) & RayActived(rayTemplate)) {
        const int lcount = min(RAY_BLOCK materialUniform.lightcount, 16);
        vec3 origin = rayTemplate.origin.xyz;
        vec3 direct = dcts(rayTemplate.cdirect.xy);

#ifdef ENABLE_PT_SUNLIGHT
        [[unroll]]
        for (int i=0;i<lcount;i++) {
            float md = 1.0f;
            float dt = intersectSphere(origin = fma(direct, -compositedHit.uvt.zzz, origin), direct, lightCenter(i).xyz, lightUniform.lightNode[i].lightColor.w + GAP);
            float t = md * dt;
            IF (lessF(dt, INFINITY) & lessEqualF(t, compositedHit.uvt.z)) lc = i;
        }
#endif
    }

    // shade light
    if (lc >= 0 && (RayTargetLight(rayTemplate) == lc || RayType(rayTemplate) != 2) && SSC(RayActived(rayTemplate))) {
        // if diffuse, shade as non-shaded (absorb), because for it have direct light
        vec4 lcolor = vec4(getLightColor(lc), 1.f);

// depend by direct light flag enabled
#ifdef DIRECT_LIGHT_ENABLED
        WriteColor(rayTemplate.dcolor, RayType(rayTemplate) == 1 ? 0.f.xxxx : f16_f32(rayTemplate.dcolor) * lcolor);
#else
        WriteColor(rayTemplate.dcolor, f16_f32(rayTemplate.dcolor) * lcolor);
#endif

        RayActived(rayTemplate, false_);
        skipping = true;
    }

    // apply background
    vec4 color = vec4(0.0f); EnvironmentShader(color, rayTemplate); //color.xyz = toLinear(max(color.xyz, vec3(0.f)));
    if (wasHit == -1 && SSC(RayActived(rayTemplate)) && RayType(rayTemplate) != 2) {
        WriteColor(rayTemplate.dcolor, f16_f32(rayTemplate.dcolor) * vec4(color.xyz, 1.f));
        RayActived(rayTemplate, false_);
        skipping = true;
    }

    // wrong ray?
    if (wasHit == -1 && SSC(RayActived(rayTemplate))) {
        RayActived(rayTemplate, false_);
        WriteColor(rayTemplate.dcolor, 0.0f.xxxx);
        skipping = true;
    }

    return rayTemplate;
}


LOCAL_SIZE_LAYOUT;



void equatePowers(inout vec3 srcColor, inout vec3 dstColor, inout float srcFactor, inout float dstFactor) {
    // impossible to equate, i have no enough math
}


void main() {
    int wsize = RAY_BLOCK samplerUniform.blockCount;
    int wcsize = int(gl_WorkGroupSize.x) / int(Wave_Size_RT);
    int wcount = min(tiled(wsize, wcsize), 1000000);

    // invoke available blocks
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = (w + int(gl_WorkGroupID.x)) * wcsize + int(Wave_Idx);
        globalInvocationSMP = globalID;

        // check if not reached blocks limit
        bool overflow = globalID >= wsize;
        IFALL (overflow) break;
        IFANY (!overflow) {
            
            // accquire shading block
            currentBlock = -1;
            if (!overflow) accquireBlock(globalID);
            bool invld = anyInvoc(overflow || currentBlock < 0 || currentBlockSize <= 0);
            if (invld) { currentBlock = -1; continue; }
            
            resetBlockIndiceCounter(currentBlock);
            int shadowBlock = int(-1), emissionBlock = int(-1), diffuseBlock = int(-1), reflectionBlock = int(-1), transparentBlock = int(-1), envBlock = int(-1);

            // invoke block data
            if (!invld) {
                int bts = min(int(R_BLOCK_SIZE), int(currentBlockSize));
                for (int tb = 0; tb < bts; tb += int(Wave_Size_RT)) {
                    SB_BARRIER
                    int nid = tb + int(Lane_Idx);
                    
                    bool overflow = invld || overflow || nid >= bts || nid < 0;
                    IFALL(overflow) break;
                    accquireNodeOffload(nid); overflow = overflow || currentBlockNode < 0;
                    IFALL(overflow) break;

                    randomClocks = 0; // reset random clocks
                    subHash = currentBlockNode; 

                    // get surface information
                    int rayState = invokeSurface(overflow);

                    // get normals
                    vec3 bitangent = compositedHit.bitangent.xyz;
                    vec3 tangent = compositedHit.tangent.xyz;
                    vec3 normal = compositedHit.normalHeight.xyz;
                    mat3 tbn = mat3(tangent, bitangent, normal);

                    // get texture composition data
                    vec4 diffcolor = compositedHit.albedo;
                    vec4 emiscolor = compositedHit.emission;
                    vec4 speccolor = compositedHit.specularGlossiness;

                    float spwr = clamp01(max3_vec(speccolor.xyz)); // specular power
                    float dpwr = clamp01(max3_vec(diffcolor.xyz));
                    float prio = clamp01(spwr + (1.f - dpwr) * (1.f - spwr));

                    // accurate version (no extra divison)
                    vec3 speccolorRef = clamp01(speccolor.xyz);                // no extra divion and multiply with "prior"
                    vec3 diffcolorRef = clamp01(diffcolor.xyz * (1.f - spwr)); // no extra divion and multiply with "prior"

                    // correction coefficents (may inaccurate in most cases)
                    speccolor.xyz = clamp01(speccolor.xyz * (1.f / prio));
                    diffcolor.xyz = clamp01(diffcolor.xyz * (1.f - spwr) / (1.f - prio));

                    // coefficents
                    float prom = 1.f - diffcolor.w; // transmission power
#ifdef USE_TRUE_METHOD
                    float spca = spwr;
#else
                    float spca = prio; // power of specularity
#endif

                    // if environment shaded, do by defaultly as transaparent, by inactive
                    if ( rayState == 3 || rayState == 1 ) prom = 1.0f;

                    // pre-filter rays in block
                    int overwriteBlock = currentBlock;
                    RayRework enrollRay = envShading(currentRay, overflow);

                    // binarize/quantize specular and transparency
#ifdef USE_TRUE_METHOD
                    float qprom = qrand(prom), qspca = spca;
#else
                    float qprom = qrand(prom), qspca = qrand(spca);
#endif
                    RayRework finalRay = enrollRay;

                    { // transparent rays 
                        RayRework transpRay = promised(enrollRay, tbn);
                        WriteColor(transpRay.dcolor, f16_f32(transpRay.dcolor) * (RayType(enrollRay) == 2 ? prom : qprom)); // shadows dims 
                        invalidateRay(transpRay, false);
                        // if transparent ray no came
                        //if (!SSC(RayActived(transpRay))) { qprom = prom; }
                        finalRay = transpRay; // prefer transparent ray by default
                    }

                    // occopy 64 byte (64kb)
                    float gloss = speccolor.w; // roughness
#ifdef USE_TRUE_METHOD
                    RayRework 
                        diffuseRay = diffuse(enrollRay, clamp01(diffcolorRef * (1.f - qprom)), tbn),
                        reflectionRay = reflection(enrollRay, clamp01(speccolorRef * (1.f - qprom)), tbn, gloss);
#else
                    RayRework 
                        diffuseRay = diffuse(enrollRay, clamp01(diffcolor.xyz * (1.f - qspca) * (1.f - qprom)), tbn),
                        reflectionRay = reflection(enrollRay, clamp01(speccolor.xyz * qspca * (1.f - qprom)), tbn, gloss);
#endif

                    // pre-filtering of quant rays
                    invalidateRay(diffuseRay, false);
                    invalidateRay(reflectionRay, false);

                    // make sure if diffuse exist
#ifndef USE_TRUE_METHOD
                    if (SSC(RayActived(diffuseRay)) && max3_vec(f16_f32(diffuseRay.dcolor).xyz) >= 0.00001f) finalRay = diffuseRay;
#endif

                    // make sure of reflection/transparency exist, and push ray block
                    if (SSC(RayActived(reflectionRay)) && max3_vec(f16_f32(reflectionRay.dcolor).xyz) >= 0.00001f) finalRay = reflectionRay;
                    invokeBlockForNodes(finalRay, reflectionBlock, overwriteBlock);

                    // push diffuses separatly
#ifdef USE_TRUE_METHOD
                    invokeBlockForNodes(diffuseRay, diffuseBlock, overwriteBlock);
#endif

                    { // shadow rays from surface
                        RayRework shadowRay = directLight(0, enrollRay, clamp01(diffcolorRef * (1.f - prom)), tbn);
                        invokeBlockForNodes(shadowRay, shadowBlock, overwriteBlock);
                    }

                    overwriteBlock = -1;

                    // final emission 
                    RayRework emisRay = enrollRay;

                    // variants of emissions
                    RayRework emRay = enrollRay;
                    RayRework envRay = enrollRay;

                    // all environment and lighting blocks to finishing
                    { // environment (finish) rays
                        WriteColor(envRay.dcolor, f16_f32(envRay.dcolor) * qprom ); // shadows dims 
                        IF (RayActived(envRay)) WriteColor(envRay.dcolor, 0.0f.xxxx); // any actives inaccessible
                        RayActived(envRay, false_);
                    }
                    
                    {
                        // PBR emissions
                        emRay = emissive(enrollRay, emiscolor.xyz * (1.f - qprom), tbn);
                        IF (RayActived(emRay)) WriteColor(emRay.dcolor, 0.0f.xxxx); // any actives inaccessible
                        RayActived(emRay, false_);
                    }

                    // final emission
                    emisRay = max3_vec(f16_f32(emRay.dcolor).xyz) >= 0.00001f ? emRay : envRay;
                    invokeBlockForNodes(emisRay, emissionBlock, overwriteBlock);
                }
            }

            SB_BARRIER
            { // confirm or emit blocks
                emitBlock(currentBlock);
                emitBlock(transparentBlock);
                emitBlock(reflectionBlock);
                emitBlock(diffuseBlock);
                emitBlock(shadowBlock);
                emitBlock(envBlock);
                emitBlock(emissionBlock);
            }
            
        }
    }
}
