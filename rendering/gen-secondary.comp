#version 460 core
#extension GL_GOOGLE_include_directive : enable

#ifdef INTEL_PLATFORM
#undef Wave_Size
#define Wave_Size 8
#endif

#ifndef MAX_DEPTH
#define MAX_DEPTH 16
#endif

#define USE_EXTENDED_RAYLIB
#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define ROLE_ABILATION

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/rayslib.glsl"
#include "../include/random.glsl"
#include "../include/mathlib.glsl"
#include "../include/shadinglib.glsl"
#include "./submodules/environment.glsl"

struct SurfaceUnpacked {
     vec4 uvt; // UV, distance, triangle
     vec4 normalHeight; // normal with height mapping, will already interpolated with geometry
     vec4 metallicRoughness;
     vec4 tangent;
     vec4 bitangent;

    // color parameters
     vec4 emission;
     vec4 albedo;
} compositedHit;

int wasHit = -1;
#define hasProcedural (proceduralID != -1)

//#define hit firstHit

// ray hit states 
// 0 - invalid hit
// 1 - shadow, have no hit in traversing (enviroment only)
// 5 - shadow, may overlap with geometry
// 3 - regular, have no intersection (environment)
// 7 - regular, have intersection

// bitfield of state
// 0 - activity of incoming ray
// 1 - shadow ray type 
// 2 - have intersection status or not

int invokeSurface(inout bool overflow) {
    HitData hit; hit.payloadID = 0; wasHit = -1; // initial hit

    // initial composition
    compositedHit.uvt = vec4(vec2(0.f), INFINITY, intBitsToFloat(-1));
    compositedHit.emission = vec4(0.f);
    compositedHit.albedo = vec4(0.f,0.f,0.f,0.f);
    compositedHit.normalHeight = vec4(0.f);
    compositedHit.metallicRoughness = vec4(0.f);
    compositedHit.tangent = vec4(0.f);

    // if hit was had
    wasHit = overflow ? -1 : floatBitsToInt(currentRay.origin.w)-1;
    if (wasHit >= 0) hit = hits[wasHit]; else wasHit = -1;

    // load from payload if has
    IF (hit.payloadID > 0 && wasHit >= 0) { // if none, make as transparent
        HitPayload hitp = hitPayload[hit.payloadID-1];
        compositedHit.uvt = hit.uvt;
        compositedHit.albedo = f16_f32(hitp.albedo);
        compositedHit.emission = f16_f32(hitp.emission);
        compositedHit.metallicRoughness.xy = f16_f32(hitp.metallicRoughness).xy;
        compositedHit.normalHeight = hitp.normalHeight;
        compositedHit.tangent = hit.tangent;
        compositedHit.bitangent = hit.bitangent;
    } else {
        wasHit = -1;
    }

    IF (greaterEqualF(compositedHit.uvt.z, INFINITY-0.0001f)) wasHit = -1;
    WriteColor(currentRay.dcolor, vec4(max(0.0f.xxxx, f16_f32(currentRay.dcolor)).xyz, 1.f));
    currentRay.origin.xyz = fma(dcts(currentRay.cdirect.xy), compositedHit.uvt.zzz, currentRay.origin.xyz); // current set origin by distance
    currentRay.origin.w = FINT_ZERO; // reset chains
    if (overflow) RayActived(currentRay, false_); // if had overflow, invalidate ray

    // getting ray state
    int rayState = 0; // invalid ray 
    if (SSC(RayActived(currentRay)) && max3_vec(f16_f32(currentRay.dcolor.xy).xyz) >= 0.00001f) {
        if (RayType(currentRay) == 2) {
            rayState = wasHit >= 0 ? 5 : 1;
        } else {
            rayState = wasHit >= 0 ? 7 : 3;
        }
    }
    return rayState;
}

RayRework envShading(in RayRework rayTemplate, inout bool skipping) {

    // bad ray
    if (skipping) {
        RayActived(rayTemplate, false_);
        WriteColor(rayTemplate.dcolor, 0.f.xxxx);
    }

    // apply physical lights
    int lc = -1;
    IF (RayDL(rayTemplate) & RayActived(rayTemplate)) {
        const int lcount = min(RAY_BLOCK materialUniform.lightcount, 16);
        vec3 origin = rayTemplate.origin.xyz;
        vec3 direct = dcts(rayTemplate.cdirect.xy);

#ifdef ENABLE_PT_SUNLIGHT
        [[unroll]]
        for (int i=0;i<lcount;i++) {
            float md = 1.0f;
            float dt = intersectSphere(origin = fma(direct, -compositedHit.uvt.zzz, origin), direct, lightCenter(i).xyz, lightUniform.lightNode[i].lightColor.w + GAP);
            float t = md * dt;
            IF (lessF(dt, INFINITY) & lessEqualF(t, compositedHit.uvt.z)) lc = i;
        }
#endif
    }

    // shade light
    if (lc >= 0 && (RayTargetLight(rayTemplate) == lc || RayType(rayTemplate) != 2) && SSC(RayActived(rayTemplate))) {
        // if diffuse, shade as non-shaded (absorb), because for it have direct light
        vec4 lcolor = vec4(getLightColor(lc), 1.f);

// depend by direct light flag enabled
#ifdef DIRECT_LIGHT_ENABLED
        WriteColor(rayTemplate.dcolor, RayType(rayTemplate) == 1 ? 0.f.xxxx : f16_f32(rayTemplate.dcolor) * lcolor);
#else
        WriteColor(rayTemplate.dcolor, f16_f32(rayTemplate.dcolor) * lcolor);
#endif

        RayActived(rayTemplate, false_);
        skipping = true;
    }

    // apply background
    vec4 color = vec4(0.0f); EnvironmentShader(color, rayTemplate); //color.xyz = toLinear(max(color.xyz, vec3(0.f)));
    if (wasHit == -1 && SSC(RayActived(rayTemplate)) && RayType(rayTemplate) != 2) {
        WriteColor(rayTemplate.dcolor, f16_f32(rayTemplate.dcolor) * vec4(color.xyz, 1.f));
        RayActived(rayTemplate, false_);
        skipping = true;
    }

    // wrong ray?
    if (wasHit == -1 && SSC(RayActived(rayTemplate))) {
        RayActived(rayTemplate, false_);
        WriteColor(rayTemplate.dcolor, 0.0f.xxxx);
        skipping = true;
    }

    return rayTemplate;
}


LOCAL_SIZE_LAYOUT;


void main() {
    //#define wsize RAY_BLOCK samplerUniform.blockCount
    int wsize = RAY_BLOCK samplerUniform.blockCount;
    int wcsize = int(gl_WorkGroupSize.x) / int(Wave_Size_RT);
    int wcount = min(tiled(wsize, wcsize), 1000000);

    // invoke available blocks
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = (w + int(gl_WorkGroupID.x)) * wcsize + int(Wave_Idx);
        globalInvocationSMP = globalID;

        // check if not reached blocks limit
        bool overflow = globalID >= wsize;
        IFALL (overflow) break;
        IFANY (!overflow) {
            
            // accquire shading block
            currentBlock = -1;
            if (!overflow) accquireBlock(globalID);
            bool invld = anyInvoc(overflow || currentBlock < 0 || currentBlockSize <= 0);
            if (invld) { currentBlock = -1; continue; }
            
            resetBlockIndiceCounter(currentBlock);
            int shadowBlock = int(-1), emissionBlock = int(-1), diffuseBlock = int(-1), reflectionBlock = int(-1), transparentBlock = int(-1), envBlock = int(-1);

            // invoke block data
            if (!invld) {
                int bts = min(int(R_BLOCK_SIZE), int(currentBlockSize));
                for (int tb = 0; tb < bts; tb += int(Wave_Size_RT)) {
                    SB_BARRIER
                    int nid = tb + int(Lane_Idx);
                    
                    bool overflow = invld || overflow || nid >= bts || nid < 0;
                    IFALL(overflow) break;
                    accquireNodeOffload(nid); overflow = overflow || currentBlockNode < 0;
                    IFALL(overflow) break;

                    randomClocks = 0; // reset random clocks
                    subHash = currentBlockNode; 

                    // get surface information
                    int rayState = invokeSurface(overflow);

                    // constants
                    const float IOR = 1.400f;
                    const float diffuse_min_importance = 0.5f;
                    const float reflect_min_importance = 0.5f;
                    const vec3 max_fresnel_color = toLinear(vec3(1.f));
                    const vec3 min_fresnel_color = toLinear(vec3(1.f));

                    // get normals
                    vec3 bitangent = compositedHit.bitangent.xyz;
                    vec3 tangent = compositedHit.tangent.xyz;
                    vec3 normal = compositedHit.normalHeight.xyz;
                    mat3 tbn = mat3(tangent, bitangent, normal);

                    // get texture composition data
                    vec4 diffcolor = compositedHit.albedo;
                    vec4 emiscolor = compositedHit.emission;
                    float refly = compositedHit.metallicRoughness.x; // roughness
                    float metallic = sqrt(compositedHit.metallicRoughness.y); // metallic

                    vec3 freflcolor = fmix(max_fresnel_color * 0.9f, min_fresnel_color * 0.04f, clamp(pow(abs(dot(dcts(currentRay.cdirect.xy), normal)), IOR - 1.f), 0.0f, 1.0f).xxx);
                    vec3 speccolor = fmix(freflcolor * mix(1.f.xxx, diffcolor.xyz, 0.04f.xxx), diffcolor.xyz + emiscolor.xyz, metallic.xxx);
                    
                    // coefficents
                    float prom = clamp01(1.f - diffcolor.w); // transmission power
                    float spca = fmix(max3_vec(freflcolor), 1.f, metallic.x);

                    // if environment shaded, do by defaultly as transaparent, by inactive
                    if ( rayState == 3 || rayState == 1 ) prom = 1.0f;

                    // pre-filter rays in block
                    int overwriteBlock = currentBlock;
                    RayRework enrollRay = envShading(currentRay, overflow);

                    // binarize/quantize specular and transparency
                    float qprom = qrand(prom), qspca = qrand(spca);


                    RayRework finalRay = enrollRay;

                    { // transparent rays 
                        RayRework transpRay = promised(enrollRay, tbn);
                        WriteColor(transpRay.dcolor, f16_f32(transpRay.dcolor) * (RayType(enrollRay) == 2 ? prom : qprom)); // shadows dims 
                        //invokeBlockForNodes(transpRay, transparentBlock, overwriteBlock); // don't over block

                        // if transparent ray no came
                        if (!SSC(RayActived(transpRay)) && qprom > 0.9999f) { qprom = prom; }
                        finalRay = transpRay; // prefer transparent ray by default
                    }

                    // if incedent ray is diffuse or shadowed, don't distribute indirect light directly (it can be approximated, for example, VCT)
                    bool deepIndirectIlluminated = false;
                    //if (RayType(enrollRay) == 1) { diffcolor *= 0.f.xxxx; deepIndirectIlluminated = true;  }
                    // TODO: approximate indirect diffuses

                    // occopy 64 byte (64kb)
                    RayRework 
                        diffuseRay = diffuse(enrollRay, diffcolor.xyz * (1.f - qspca) * (1.f - qprom), tbn),
                        reflectionRay = reflection(enrollRay, speccolor.xyz * qspca * (1.f - qprom), tbn, refly);

                    // pre-filtering of quant rays
                    invalidateRay(diffuseRay, false);
                    invalidateRay(reflectionRay, false);

                    // if diffuse ray can't done own role, give to reflection 
                    if (!SSC(RayActived(diffuseRay)) /*&& qspca < 0.00001f*/) {
                        qspca = spca;
                        reflectionRay = reflection(enrollRay, speccolor.xyz / precIssue(spca) * qspca * (1.f - qprom), tbn, refly);
                        invalidateRay(reflectionRay, false);
                    }

                    // if reflection ray can't done own role, give to diffuse 
                    if (!SSC(RayActived(reflectionRay)) /*&& qspca > 0.99999f*/) { 
                        qspca = spca;
                        diffuseRay = diffuse(enrollRay, diffcolor.xyz / precIssue(1.f - spca) * (1.f - qspca) * (1.f - qprom), tbn);
                        invalidateRay(diffuseRay, false);
                    }

                    // choice what ray will heading
                    if (SSC(RayActived(diffuseRay)) && max3_vec(f16_f32(diffuseRay.dcolor).xyz) >= 0.00001f) finalRay = diffuseRay;
                    if (SSC(RayActived(reflectionRay)) && max3_vec(f16_f32(reflectionRay.dcolor).xyz) >= 0.00001f) finalRay = reflectionRay;

                    { // diffuse rays from surface
                        invalidateRay(finalRay, false);
                        invokeBlockForNodes(finalRay, diffuseBlock, overwriteBlock);
                    }

                    { // shadow rays from surface
                        RayRework shadowRay = directLight(0, enrollRay, diffcolor.xyz * (1.f - spca) * (1.f - prom), tbn);
                        invokeBlockForNodes(shadowRay, shadowBlock, overwriteBlock);
                    }

                    overwriteBlock = -1;

                    // final emission 
                    RayRework emisRay = enrollRay;

                    // variants of emissions
                    RayRework emRay = enrollRay;
                    RayRework envRay = enrollRay;

                    // all environment and lighting blocks to finishing
                    { // environment (finish) rays
                        WriteColor(envRay.dcolor, f16_f32(envRay.dcolor) * qprom ); // shadows dims 
                        IF (RayActived(envRay)) WriteColor(envRay.dcolor, 0.0f.xxxx); // any actives inaccessible
                        RayActived(envRay, false_);
                        //invokeBlockForNodes(envRay, envBlock, overwriteBlock);
                    }
                    
                    { // PBR emissions
                        emRay = emissive(enrollRay, emiscolor.xyz * (1.f - qprom), tbn);

                        // if you want use simple mode with correct reflection coefficents, uncomment this line
                        //WriteColor(emRay.dcolor, f16_f32(emRay.dcolor) * (1.f - spca));

                        IF (RayActived(emRay)) WriteColor(emRay.dcolor, 0.0f.xxxx); // any actives inaccessible
                        //invokeBlockForNodes(emRay, emissionBlock, overwriteBlock);
                    }

                    // final emission
                    emisRay = max3_vec(f16_f32(emRay.dcolor).xyz) >= 0.00001f ? emRay : envRay;
                    invokeBlockForNodes(emisRay, emissionBlock, overwriteBlock);
                }
            }

            SB_BARRIER
            { // confirm or emit blocks
                emitBlock(currentBlock);
                emitBlock(transparentBlock);
                emitBlock(reflectionBlock);
                emitBlock(diffuseBlock);
                emitBlock(shadowBlock);
                emitBlock(envBlock);
                emitBlock(emissionBlock);
            }
            
        }
    }
}
