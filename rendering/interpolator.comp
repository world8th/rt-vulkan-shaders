#version 460 core
#extension GL_GOOGLE_include_directive : enable

// THIS shader now not part of ray tracing pipeline - it part of BVH processing system

#define USE_SINGLE_THREAD_RAY_MANAGMENT
#define SIMPLIFIED_RAY_MANAGMENT
#define DISCARD_SHARED_CACHING // store rays in registers if possible
#define ENABLE_VSTORAGE_DATA
#define ENABLE_VERTEX_INTERPOLATOR
#define DMA_HIT

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/morton.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"

#include "./submodules/shared-data.glsl"

LOCAL_SIZE_LAYOUT;

#define cray unorderedRays[hit.rayID-1]

void main() {
    int wsize = int(arcounter.hT);
    int wcount = min(tiled(wsize, int(gl_WorkGroupSize.x)), 1000000);
    bool overflow = false;
    int wgs = int(gl_NumWorkGroups);
    for (int w=0;w<wcount;w+=wgs) {
        SB_BARRIER
        int globalID = (w + int(gl_WorkGroupID.x)) * int(gl_WorkGroupSize.x) + int(gl_LocalInvocationID.x);
        bool overflow = overflow || globalID >= wsize || globalID < 0;
        
        int matID = -1;
        IFALL(overflow) break;
        {
#ifdef DMA_HIT
            #define hit hits[globalID]
#else
            HitData hit = hits[globalID];
#endif

            const int trid = floatBitsToInt(hit.uvt.w)-1;
            const int itri = trid*3;//trid*9;
            const mat3 vertexInterp = mat3(
                imageLoad(lvtx, itri+0).xyz,
                imageLoad(lvtx, itri+1).xyz,
                imageLoad(lvtx, itri+2).xyz
                //vec3(lvtx[itri+0], lvtx[itri+1], lvtx[itri+2]),
                //vec3(lvtx[itri+3], lvtx[itri+4], lvtx[itri+5]),
                //vec3(lvtx[itri+6], lvtx[itri+7], lvtx[itri+8])
            );


            // check dimension error and interpolate
            const vec3 vs = vec3(1.0f - hit.uvt.x - hit.uvt.y, hit.uvt.xy); 
            const vec3 pos = vs * vertexInterp;

            // 
            IF (trid >= 0 && !overflow && abs(length(pos.xyz - cray.origin.xyz) - hit.uvt.z) < 0.1f && cray.uindex.x > 0) {
                interpolateMeshData(hit);
                hit.rayID = cray.uindex.x;
#ifndef DMA_HIT
                hits[globalID] = hit;
#endif
            }
        }
    }
    
}
