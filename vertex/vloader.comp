#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define VERTEX_FILLING

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/vertex.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"

LOCAL_SIZE_LAYOUT;


layout(push_constant) uniform PushBlock {
    uint uniformBlock;
} push_block;


struct MeshUniformStruct {
    int vertexAccessor;
    int normalAccessor;
    int texcoordAccessor;
    int modifierAccessor;
    int materialAccessor;
    int indiceAccessor;
    int r0, r1;

    mat4 transform;
    mat4 transformInv;

    int materialID;
    int int16bit;
    int nodeCount;
    int primitiveType;
};

// subdata structuring in buffer region
struct VirtualBufferView {
    int byteOffset;
    int byteStride;
    int bufferID;
};

// structuring swizzle
struct VirtualDataAccess {
    int bufferView; // buffer-view structure
    int byteOffset; // in structure offset
    uint bitfield;
};

// structure accessors 
struct VirtualBufferBinding {
    int bufferID; // buffer region PTR, override
    int dataAccess; // structure accessor
    int indexOffset; // structure index offset (where should be counting), so offset calculates as   (bv.byteOffset + indexOffset*bv.byteStride + ac.byteOffset)
};



const ivec2 COMPONENTS = ivec2(0, 2);
const ivec2 ATYPE = ivec2(2, 4);
const ivec2 NORMALIZED = ivec2(6, 1);

int aComponents(in VirtualDataAccess vac) {
    return parameteri(COMPONENTS, vac.bitfield);
}

int aType(in VirtualDataAccess vac) {
    return parameteri(ATYPE, vac.bitfield);
}

int aNormalized(in VirtualDataAccess vac) {
    return parameteri(NORMALIZED, vac.bitfield);
}



// input data of vertex instance
layout ( std430, binding = 0, set = 1 ) readonly buffer bufferSpaceB {INDEX16 bufferSpace[]; };
layout ( std430, binding = 1, set = 1 ) readonly buffer bufferRegionsB {uvec2 bufferRegions[]; };
layout ( std430, binding = 2, set = 1 ) readonly buffer bufferViewsB {VirtualBufferView bufferViews[]; };
layout ( std430, binding = 3, set = 1 ) readonly buffer dataFormatsB {VirtualDataAccess dataFormats[]; };
layout ( std430, binding = 4, set = 1 ) readonly buffer dataBindingsB {VirtualBufferBinding dataBindings[]; };
layout ( std430, binding = 5, set = 1 ) readonly buffer uMeshUniformB {MeshUniformStruct uMeshUniform[]; };

#define meshUniform uMeshUniform[push_block.uniformBlock + gl_GlobalInvocationID.y]



uint calculateByteOffset(in int binding, in uint index, in uint bytecorrect){
    int bufferID = dataBindings[binding].bufferID, 
        dataAccess = dataBindings[binding].dataAccess, 
        bufferView = dataFormats[dataAccess].bufferView;

    // if no direct buffer binding, pick from buffer view
    if (bufferID < 0) bufferID = bufferViews[bufferView].bufferID;

    // based on regions byte offset
    uint offseT = bufferRegions[bufferID].x;

    // calculate byte offset 
    offseT += bufferViews[bufferView].byteOffset + dataFormats[dataAccess].byteOffset;

    // get true stride 
    uint stride = max(bufferViews[bufferView].byteStride, (aComponents(dataFormats[dataAccess])+1) << bytecorrect);

    // calculate structure indexed offset
    offseT += (dataBindings[binding].indexOffset + index) * stride;

    // 
    return offseT >> bytecorrect;
}

void readByAccessor(in int binding, in uint index, inout vec4 outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index, 2);
        uint C = aComponents(dataFormats[dataBindings[binding].dataAccess])+1;
        if (C >= 1) outp.x = uintBitsToFloat(M32(bufferSpace,T+0));
        if (C >= 2) outp.y = uintBitsToFloat(M32(bufferSpace,T+1));
        if (C >= 3) outp.z = uintBitsToFloat(M32(bufferSpace,T+2));
        if (C >= 4) outp.w = uintBitsToFloat(M32(bufferSpace,T+3));
    }
}

void readByAccessor(in int binding, in uint index, inout vec3 outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index, 2);
        uint C = aComponents(dataFormats[dataBindings[binding].dataAccess])+1;
        if (C >= 1) outp.x = uintBitsToFloat(M32(bufferSpace,T+0));
        if (C >= 2) outp.y = uintBitsToFloat(M32(bufferSpace,T+1));
        if (C >= 3) outp.z = uintBitsToFloat(M32(bufferSpace,T+2));
    }
}

void readByAccessor(in int binding, in uint index, inout vec2 outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index, 2);
        uint C = aComponents(dataFormats[dataBindings[binding].dataAccess])+1;
        if (C >= 1) outp.x = uintBitsToFloat(M32(bufferSpace,T+0));
        if (C >= 2) outp.y = uintBitsToFloat(M32(bufferSpace,T+1));
    }
}

void readByAccessor(in int binding, in uint index, inout float outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index, 2);
        outp = uintBitsToFloat(M32(bufferSpace,T+0));
    }
}

void readByAccessor(in int binding, in uint index, inout int outp) {
    if (binding >= 0) {
        uint T = calculateByteOffset(binding, index, 2);
        outp = int(M32(bufferSpace,T+0));
    }
}

// planned read type directly from accessor
void readByAccessorIndice(in int binding, in uint index, inout uint outp) {
    if (binding >= 0) {
        const bool U16 = meshUniform.int16bit > 0;
        uint T = calculateByteOffset(binding, index, U16 ? 1 : 2);
        if (U16) { outp = M16(bufferSpace,T+0); } else { outp = M32(bufferSpace,T+0); }
    }
}

const int m[3] = {0, 1, 2}, mq[3] = {3, 0, 2}, ms[3] = {2, 1, 3};
initAtomicSubgroupIncFunctionDyn(tcounter[0], tcounterInc, int)



// 

void main(){
    const int wsize = meshUniform.nodeCount;
    const int gS = int(gl_WorkGroupSize.x);
    const int wgs = int(gl_NumWorkGroups);
    const int wID = int(gl_WorkGroupID.x);
    const int lID = int(Local_Idx);
    const int rng = gS*wgs;
    for (int w=0;w<wsize;w+=rng) {
        int globalID = w + wID * gS + lID;
        if (globalID >= wsize) break;
        if (globalID < wsize && globalID >= 0) {

            // constant material ID from vertex instance 
            int matID = int(meshUniform.materialID);

            // read material per vertex if possible 
            readByAccessor(meshUniform.materialAccessor, globalID, matID);

            // default values
            vec4 vertice[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
            const int mode = meshUniform.primitiveType, trp = 3;

            [[unroll]]
            for (int i=0;i<trp;i++) {
                uint indiceID = globalID * trp + i;
                readByAccessorIndice(meshUniform.indiceAccessor, indiceID, indiceID);
                readByAccessor(meshUniform.vertexAccessor, indiceID, vertice[i]);
            }

            vec3 vnorm = normalize(cross(vertice[1].xyz - vertice[0].xyz, vertice[2].xyz - vertice[0].xyz));
            vec3 normal[4] = {vnorm, vnorm, vnorm, vnorm};
            vec4 texcoord[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
            vec4 colors[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};
            vec4 mods[4] = {vec4(0.0f), vec4(0.0f), vec4(0.0f), vec4(0.0f)};

            [[unroll]]
            for (int i=0;i<trp;i++) {
                uint indiceID = globalID * trp + i;
                readByAccessorIndice(meshUniform.indiceAccessor, indiceID, indiceID);

                if (meshUniform.normalAccessor != -1) {
                    readByAccessor(meshUniform.normalAccessor, indiceID, normal[i].xyz);
                }
                if (meshUniform.modifierAccessor != -1) {
                    readByAccessor(meshUniform.modifierAccessor, indiceID, mods[i]);
                }
                if (meshUniform.texcoordAccessor != -1) {
                    readByAccessor(meshUniform.texcoordAccessor, indiceID, texcoord[i].xy);
                }

                vertice[i] = divW(mult4(meshUniform.transform, vec4(vertice[i].xyz,1.f)));
                normal[i] = mult4(meshUniform.transformInv, vec4(normal[i].xyz, 0.0f)).xyz;
            }

            // adapt quads to triangles
            const int istride = 1;
            int ordr = tcounter[1] + int(globalID), tidc = tcounterInc(istride);

            { // planned to support quad based geometry
                vorders[tidc] = ordr;
                materials[tidc] = matID;
                
                ivec2 NORMAL_TXF = gatherMosaic(getUniformCoord(tidc*ATTRIB_EXTENT+NORMAL_TID));
                ivec2 TEXCOORD_TXF = gatherMosaic(getUniformCoord(tidc*ATTRIB_EXTENT+TEXCOORD_TID));
                ivec2 TANGENT_TXF = gatherMosaic(getUniformCoord(tidc*ATTRIB_EXTENT+TANGENT_TID));
                ivec2 BITANGENT_TXF = gatherMosaic(getUniformCoord(tidc*ATTRIB_EXTENT+BITANGENT_TID));

                mat3x2 dlts = mat3x2(texcoord[m[0]].xy, texcoord[m[1]].xy, texcoord[m[2]].xy); 
                mat3x3 dlps = mat3x3(vertice[m[0]].xyz, vertice[m[1]].xyz, vertice[m[2]].xyz);
                dlps[1] -= dlps[0], dlps[2] -= dlps[0], dlts[1] -= dlts[0], dlts[2] -= dlts[0];

                [[unroll]]
                for (int i=0;i<3;i++) {
                    const int mi = m[i];

                    // calc raw TBN 
                    float idet = 1.f/precIssue(determinant(mat2(dlts[1],dlts[2]))); // inv determinant
                    vec3 t = fma(dlts[2].yyy, dlps[1], -dlts[1].y * dlps[2]), b = fma(dlts[1].xxx, dlps[2], -dlts[2].x * dlps[1]), n = normal[mi]; // pre-tbn

                    // if texcoord not found or incorrect, calculate by axis
                    if (
                        all(lessThanEqual(abs(dlts[1]), 1e-5f.xx)) || 
                        all(lessThanEqual(abs(dlts[2]), 1e-5f.xx)) || 
                        all(lessThanEqual(abs(dlps[1]), 1e-5f.xxx)) || 
                        all(lessThanEqual(abs(dlps[2]), 1e-5f.xxx))
                    ) {
                        vec3 c0 = cross(n, vec3(0.f, 0.f, 1.f)), c1 = cross(n, vec3(0.f, 1.f, 0.f));
                        t = length(c0) >= length(c1) ? c0 : c1, b = cross(t, n);
                        idet = 1.f;
                    }
                    
                    { // orthonormalization process
                        t -= n * dot( t, n );
                        b -= n * dot( b, n );
                        b -= t * dot( b, t );
                    }

                    ISTORE(attrib_texture_out, mosaicIdc(NORMAL_TXF, i), floatBitsToUint(vec4(normalize(n), 0.0f)));
                    ISTORE(attrib_texture_out, mosaicIdc(TANGENT_TXF, i), floatBitsToUint(vec4(normalize(idet*t), 0.0f)));
                    ISTORE(attrib_texture_out, mosaicIdc(BITANGENT_TXF, i), floatBitsToUint(vec4(normalize(idet*b), 0.0f)));
                    ISTORE(attrib_texture_out, mosaicIdc(TEXCOORD_TXF, i), floatBitsToUint(vec4(texcoord[mi])));

                    // store vertex data
                    lvtx[tidc*9+3*i+0] = vertice[mi].x;
                    lvtx[tidc*9+3*i+1] = vertice[mi].y;
                    lvtx[tidc*9+3*i+2] = vertice[mi].z;
                }
            }
        }
    }
}
