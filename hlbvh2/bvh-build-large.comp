#version 460 core
#extension GL_GOOGLE_include_directive : enable

#define BVH_BUILD
#define BVH_CREATION

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"

layout(push_constant) uniform PushBlock {
    int swap;
    int count;
} cnst;

#define cBuffer cnst.swap


// shared memory counters
//shared int _counters[8];
//#define cBuffer _counters[3]

// define function for increment
//initAtomicSubgroupIncFunction(cBuffer == 1 ? aCounter2 : aCounter, aCounterInc, 1, int) // make choose by counter
initAtomicSubgroupIncFunction(aCounter, _aCounterInc, 1, int)
initAtomicSubgroupIncFunction(aCounter2, _aCounter2Inc, 1, int)

initAtomicSubgroupIncFunction(lCounter, lCounterInc, 2, int)
initAtomicSubgroupIncFunction(cCounter, cCounterInc, 1, int)
initAtomicSubgroupIncFunction(cCounter, cCounterDualInc, 2, int)

// hack with choice
int aCounterInc(){ return cBuffer == 1 ? _aCounter2Inc() : _aCounterInc(); }

#include "./bvh-build-general.glsl" // unified functions

LOCAL_SIZE_LAYOUT;

void main() {
    const int threadID = int(Local_Idx);
    const int groupSize = int(gl_WorkGroupSize.x);

    // lane-based
    const int gS = groupSize >> 1;
    const int iT = threadID >> 1;
    const int sD = threadID & 1;
    const int wS = gS * int(gl_NumWorkGroups.x);
    const int wT = gS * int(gl_WorkGroupID.x);
    
    // split nodes
    const int asize = cBuffer == 1 ? aCounter : aCounter2; //cnst.count;
    IFALL (asize >= 0) {
        for (int fT=0;fT<asize;fT+=wS) {
            // subgroup barrier
            SB_BARRIER

            // index of node element
            const int uID = fT + wT + iT; 
            
            // split prefixed elements
            IFALL (uID >= asize) break;

            // get spared prefix
            const int fID = Actives[uID][1-cBuffer]-1;
            if (sD == 0) Actives[uID][1-cBuffer] = 0;

            // split sibling nodes
            [[flatten]]
            //if (uID < asize && fID >= 0) { splitNode(fID, 0), splitNode(fID, 1); }
            if (uID < asize && fID >= 0) { splitNode(fID, sD); }
        }
    }

    // sync BVH splitting
    //LGROUP_BARRIER
}
