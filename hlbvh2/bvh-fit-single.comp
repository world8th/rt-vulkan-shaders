#version 460 core
#extension GL_GOOGLE_include_directive : enable

#ifdef NVIDIA_PLATFORM
#define WORK_SIZE_BND 1024
#else 
#define WORK_SIZE_BND 1024
#endif

#define BVH_CREATION

#include "../include/driver.glsl"
#include "../include/structs.glsl"
#include "../include/uniforms.glsl"
#include "../include/mathlib.glsl"
#include "../include/ballotlib.glsl"
#include "../include/vertex.glsl"
#include "./includes.glsl"

void unifyNodeBox(const int idx){
    // initial for unify box
    ivec4 comp = imageLoad(bvhMeta, idx)-1; // meta of contributable
    if (comp.x != comp.y && comp.x >= 0) {
        int lft = comp.x, rgh = comp.x+1, sibid = lft >> 1;

        // get contributors boxes
        mat4 lrbox = mat4(bvhBoxesWork[lft][0], bvhBoxesWork[rgh][0], bvhBoxesWork[lft][1], bvhBoxesWork[rgh][1]);

        // contribute to current node
        bvhBoxesWork[idx] = vec4[2](min(lrbox[0], lrbox[1]), max(lrbox[2], lrbox[3]));

        // transpose and compress boxes of contributors
        lrbox = transpose(lrbox);

        // transposed save
    #ifdef USE_F32_BVH
        fvec4_ resulting[4] = { fvec4_(lrbox[0]), fvec4_(lrbox[1]), fvec4_(lrbox[2]), fvec4_(lrbox[3]) };
    #else
        uvec4 resulting[4] = {
            uvec4( packHalf16x4( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[0])) ), 0u, 0u),
            uvec4( packHalf16x4( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[1])) ), 0u, 0u),
            uvec4( packHalf16x4( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[2])) ), 0u, 0u),
            uvec4( packHalf16x4( fma(fvec4_(-1e-3f.xx, 1e-3f.xx), fvec4_(0.5f.xxxx), fvec4_(lrbox[3])) ), 0u, 0u)
        };
    #endif

        // store boxes for outputs
        bvhBoxesResulting[sibid] = resulting;
    }
}

layout ( local_size_x = WORK_SIZE_BND ) in;

// shared memory counters
shared int _counters[8];
#define cBuffer _counters[3]

// define function for increment
initAtomicSubgroupIncFunction(_counters[0], aCounterInc, 1, int)

void main() {
    const int gS = int(gl_WorkGroupSize.x);
    const int wgs = 1;//int(gl_NumWorkGroups.x);
    const int wID = int(gl_WorkGroupID.x);
    const int lID = int(Local_Idx);
    const int rng = gS*wgs;

    // initial counters
    LGROUP_BARRIER
    if (lID < 8) { _counters[lID] = 0; }
    LGROUP_BARRIER

    // move to work list
    const int wsize = bvhBlock.creatorUniform.leafCount;
    for (int w=0;w<wsize;w+=rng) {
        SB_BARRIER
        const int globalID = w + (wID * gS + lID);
        IFALL (globalID >= wsize) break;

        // add to queue list parent node
        int idx = globalID < wsize ? atomicExchange(LeafIndices[globalID], 0)-1 : -1;
        if (idx >= 0) { Actives[aCounterInc()][cBuffer] = idx+1; }
    }

    // sync work
    LGROUP_BARRIER

    // upcoming to root node
    [[unroll, dependency_length(4)]]
    for (int l=0;l<65536;l++) {
        // check activity counter
        const int asize = _counters[0];
        IFALL (asize <= 0) break;

        // switch buffer and reset counter
        LGROUP_BARRIER
        if (lID == 0) { cBuffer = 1-cBuffer; _counters[0] = 0; }
        LGROUP_BARRIER

        // unify boxes when possible
        for (int w=0;w<asize;w+=rng) {
            SB_BARRIER
            
            const int globalID = w + (wID * gS + lID);
            IFALL (globalID >= wsize) break;

            // unify boxes for parent
            int idx = globalID < asize ? atomicExchange(Actives[globalID][1-cBuffer], 0)-1 : -1;
            if ( idx >= 0 ) { unifyNodeBox(idx); }

            // unify box for current and add parent
            int pid = idx >= 0 ? (imageLoad(bvhMeta, idx).z-1) : -1;
            if ( pid >= 0 && atomicCompSwap(Flags[pid], 0, 1) == 1 ) {
                Actives[aCounterInc()][cBuffer] = pid+1; // add to contributors list
            }
        }

        // sync work
        LGROUP_BARRIER
    }

    LGROUP_BARRIER
}